
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass -L PendulumDump.txt --output-exec=start --intel-hex --output pendulum.hex pendulum.asm
; Thu Mar 27 12:33:13 2025

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: pendulum.asm


;******  Processing file: setup.asm

=$01					MMU_IO_CTRL 	= $01						;MMU I/O Control
=$d000					VKY_MSTR_CTRL_0 = $d000						; Vicky Master Control Register 0
=$d001					VKY_MSTR_CTRL_1 = $d001						; Vicky Master Control Register 1
=$d004					VKY_BRDR_CTRL   = $d004						; Vicky Border Control Register
=$d00d					VKY_BKG_COL_B   = $d00d						; Vicky Graphics Background Color Blue
=$d00e					VKY_BKG_COL_G   = $d00e						; Vicky Graphics Background Color Green
=$d00f					VKY_BKG_COL_R   = $d00f						; Vicky Graphics Background Color Red
=$d002					VKY_LAYER_CTRL_0= $d002
=$d003					VKY_LAYER_CTRL_1= $d003
=$d280					VKY_TS0_AD_L	= $d280						; Vicky Tile 0 Image Start Address LOW BYTE
=$d281					VKY_TS0_AD_M	= $d281						; Vicky Tile 0 Image Start Address MEDIUM BYTE
=$d282					VKY_TS0_AD_H	= $d282						; Vicky Tile 0 Image Start Address HIGH BYTE
=$d284					VKY_TS1_AD_L	= $d284						; Vicky Tile 1 Image Start Address LOW BYTE
=$d285					VKY_TS1_AD_M	= $d285						; Vicky Tile 1 Image Start Address MEDIUM BYTE
=$d286					VKY_TS1_AD_H	= $d286						; Vicky Tile 1 Image Start Address HIGH BYTE
=$d288					VKY_TS2_AD_L	= $d288						; Vicky Tile 2 Image Start Address LOW BYTE
=$d289					VKY_TS2_AD_M	= $d289						; Vicky Tile 2 Image Start Address MEDIUM BYTE
=$d28a					VKY_TS2_AD_H	= $d28a						; Vicky Tile 2 Image Start Address HIGH BYTE
=$d200					VKY_TM0_CTRL	= $d200						; Tile Map 0 Control
=$d201					VKY_TM0_AD_L	= $d201						; Tile Map 0 Start Address LOW BYTE
=$d202					VKY_TM0_AD_M	= $d202						; Tile Map 0 Start Address MEDIUM BYTE
=$d203					VKY_TM0_AD_H	= $d203						; Tile Map 0 Start Address HIGH BYTE
=$d204					VKY_TM0_SZ_X	= $d204						; Tile Map 0 Size X
=$d206					VKY_TM0_SZ_Y	= $d206						; Tile Map 0 Size Y
=$d208					VKY_TM0_POS_X_L = $d208						; Tile Map 0 X Position & Scroll LOW BYTE
=$d209					VKY_TM0_POS_X_H = $d209						; Tile Map 0 X Position & Scroll HIGH BYTE
=$d20a					VKY_TM0_POS_Y_L = $d20a						; Tile Map 0 Y Position & Scroll LOW BYTE
=$d20b					VKY_TM0_POS_Y_H = $d20b						; Tile Map 0 Y Position & Scroll HIGH BYTE
=$d20c					VKY_TM1_CTRL	= $d20c						; Tile Map 1 Control
=$d20d					VKY_TM1_AD_L	= $d20d						; Tile Map 1 Start Address LOW BYTE
=$d20e					VKY_TM1_AD_M	= $d20e						; Tile Map 1 Start Address MEDIUM BYTE
=$d20f					VKY_TM1_AD_H	= $d20f						; Tile Map 1 Start Address HIGH BYTE
=$d210					VKY_TM1_SZ_X	= $d210						; Tile Map 1 Size X
=$d212					VKY_TM1_SZ_Y	= $d212						; Tile Map 1 Size Y
=$d214					VKY_TM1_POS_X_L = $d214						; Tile Map 1 X Position & Scroll LOW BYTE
=$d215					VKY_TM1_POS_X_H = $d215						; Tile Map 1 X Position & Scroll HIGH BYTE
=$d216					VKY_TM1_POS_Y_L = $d216						; Tile Map 1 Y Position & Scroll LOW BYTE
=$d217					VKY_TM1_POS_Y_H = $d217						; Tile Map 1 Y Position & Scroll HIGH BYTE
=$d218					VKY_TM2_CTRL	= $d218						; Tile Map 2 Control
=$d219					VKY_TM2_AD_L	= $d219						; Tile Map 2 Start Address LOW BYTE
=$d21a					VKY_TM2_AD_M	= $d21a						; Tile Map 2 Start Address MEDIUM BYTE
=$d21b					VKY_TM2_AD_H	= $d21b						; Tile Map 2 Start Address HIGH BYTE
=$d21c					VKY_TM2_SZ_X	= $d21c						; Tile Map 2 Size X
=$d21e					VKY_TM2_SZ_Y	= $d21e						; Tile Map 2 Size Y
=$d220					VKY_TM2_POS_X_L = $d220						; Tile Map 2 X Position & Scroll LOW BYTE
=$d221					VKY_TM2_POS_X_H = $d221						; Tile Map 2 X Position & Scroll HIGH BYTE
=$d222					VKY_TM2_POS_Y_L = $d222						; Tile Map 2 Y Position & Scroll LOW BYTE
=$d223					VKY_TM2_POS_Y_H = $d223						; Tile Map 2 Y Position & Scroll HIGH BYTE
=$d900					VKY_SP0         = $d900                     ; start of sprite register locations / each new aprite is a multiple of 8
=$00					SP_CTRL         = $00                       ; control register              7-x, 6/5-size, 4/3-layer, 2/1-lut, 0-enable
=$01					SP_AD_L         = $01                       ; image address location
=$02					SP_AD_M         = $02
=$03					SP_AD_H         = $03
=$04					SP_POS_X_L      = $04                       ; x position
=$05					SP_POS_X_H      = $05
=$06					SP_POS_Y_L      = $06                       ; y position
=$07					SP_POS_Y_H      = $07
=$d9a0					playerSP        = $d9a0                     ; the sprite registers for the player
=$d000					VKY_GR_CLUT_0  	= $d000						; Graphics LUT #0 in I/O page 1
=$d400					VKY_GR_CLUT_1  	= $d400						; Graphics LUT #1 in I/O page 1
=$d400					SID_L1_FREQ_L   = $d400                     ; Left Sid Registers
=$d401					SID_L1_FREQ_H   = $d401
=$d402					SID_L1_PULS_L   = $d402
=$d403					SID_L1_PULS_H   = $d403
=$d404					SID_L1_GATE     = $d404
=$d405					SID_L1_ATDL     = $d405
=$d406					SID_L1_STRL     = $d406
=$d407					SID_L2_FREQ_L   = $d407
=$d408					SID_L2_FREQ_H   = $d408
=$d409					SID_L2_PULS_L   = $d409
=$d40a					SID_L2_PULS_H   = $d40a
=$d40b					SID_L2_GATE     = $d40b
=$d40c					SID_L2_ATDL     = $d40c
=$d40d					SID_L2_STRL     = $d40d
=$d40e					SID_L3_FREQ_L   = $d40e
=$d40f					SID_L3_FREQ_H   = $d40f
=$d410					SID_L3_PULS_L   = $d410
=$d411					SID_L3_PULS_H   = $d411
=$d412					SID_L3_GATE     = $d412
=$d413					SID_L3_ATDL     = $d413
=$d414					SID_L3_STRL     = $d414
=$d415					SID_L_FLT_L     = $d415
=$d416					SID_L_FLT_H     = $d416
=$d417					SID_L_RES       = $d417
=$d418					SID_L_VOL       = $d418
=$d500					SID_R1_FREQ_L   = $d500                     ; Right Sid Registers
=$d501					SID_R1_FREQ_H   = $d501
=$d502					SID_R1_PULS_L   = $d502
=$d503					SID_R1_PULS_H   = $d503
=$d504					SID_R1_GATE     = $d504
=$d505					SID_R1_ATDL     = $d505
=$d506					SID_R1_STRL     = $d506
=$d507					SID_R2_FREQ_L   = $d507
=$d508					SID_R2_FREQ_H   = $d508
=$d509					SID_R2_PULS_L   = $d509
=$d50a					SID_R2_PULS_H   = $d50a
=$d50b					SID_R2_GATE     = $d50b
=$d50c					SID_R2_ATDL     = $d50c
=$d50d					SID_R2_STRL     = $d50d
=$d50e					SID_R3_FREQ_L   = $d50e
=$d50f					SID_R3_FREQ_H   = $d50f
=$d510					SID_R3_PULS_L   = $d510
=$d511					SID_R3_PULS_H   = $d511
=$d512					SID_R3_GATE     = $d512
=$d513					SID_R3_ATDL     = $d513
=$d514					SID_R3_STRL     = $d514
=$d515					SID_R_FLT_L     = $d515
=$d516					SID_R_FLT_H     = $d516
=$d517					SID_R_RES       = $d517
=$d518					SID_R_VOL       = $d518
=$d600					PSG_L           = $d600
=$d610					PSG_R           = $d610
=$d608					PSG_LR          = $d608
=$80					PSG1_FREQ_LO    = %10000000                 ; OR with low 4 bits
=$00					PSG1_FREQ_HI    = %00000000                 ; OR with low 6 bits
=$90					PSG1_VOLUME     = %10010000                 ; OR with low 4 bits / default is full  - 0 = full, f = silent
=$a0					PSG2_FREQ_LO    = %10100000                 ; OR with low 4 bits
=$00					PSG2_FREQ_HI    = %00000000                 ; OR with low 6 bits
=$b0					PSG2_VOLUME     = %10110000                 ; OR with low 4 bits / default is full  - 0 = full, f = silent
=$c0					PSG3_FREQ_LO    = %11000000                 ; OR with low 4 bits
=$00					PSG3_FREQ_HI    = %00000000                 ; OR with low 6 bits
=$d0					PSG3_VOLUME     = %11010000                 ; OR with low 4 bits / default is full  - 0 = full, f = silent
=$dda1					MIDI_COM        = $dda1                     ; midi command
=$fffe					VIRQ			= $fffe						; Pointer to IRQ routine (LOW Byte)
=$d660					INT_PEND_0		= $d660						; Pending register for interrupts 0-7
=$d661					INT_PEND_1		= $d661						; Pending register for interrupts 8-15
=$d66c					INT_MASK_0		= $d66c						; Mask register for interrupts 0-7
=$d66d					INT_MASK_1		= $d66d						; Mask register for interrupts 8-15
=$de00					MULU_A_L		= $de00						; unsigned A LOW byte
=$de01					MULU_A_H		= $de01						; unsigned A HIGH Byte
=$de02					MULU_B_L		= $de02						; unsigned B LOW byte
=$de03					MULU_B_H		= $de03						; unsigned B HIGH byte
=$de10					MULU_LL			= $de10						; A x B byte 0
=$de11					MULU_LH			= $de11						; A x B byte 1
=$de12					MULU_HL			= $de12						; A x B byte 3
=$de13					MULU_HH			= $de13						; A x B byte 4
=$de08					ADD_A_LL		= $de08
=$de09					ADD_A_LH		= $de09
=$de0a					ADD_A_HL		= $de0a
=$de0b					ADD_A_HH		= $de0b
=$de0c					ADD_B_LL		= $de0c
=$de0d					ADD_B_LH		= $de0d
=$de0e					ADD_B_HL		= $de0e
=$de0f					ADD_B_HH		= $de0f
=$de18					ADD_R_LL		= $de18
=$de19					ADD_R_LH		= $de19
=$de1a					ADD_R_HL		= $de1a
=$de1b					ADD_R_HH		= $de1b
=$d6a6					Random_Reg		= $d6a6
=$d6a4					Random_L		= $d6a4
=$80					ptr_src			= $80						; A pointer to read data
=$82					ptr_dst			= $82						; A pointer to write data

;******  Return to file: pendulum.asm

.1ffd					start:
.1ffd	4c 0b 20	jmp $200b			jmp SC								; Start of the program - We put this jump here so you can load the PGZ into the computer.

;******  Processing file: api.asm

>ff00					NextEvent   .fill   4   ; Copy the next event into user-space.
>ff04					ReadData    .fill   4   ; Copy primary bulk event data into user-space
>ff08					ReadExt     .fill   4   ; Copy secondary bolk event data into user-space
>ff0c					Yield       .fill   4   ; Give unused time to the kernel.
>ff10					Putch       .fill   4   ; deprecated
>ff14					RunBlock    .fill   4   ; Chain to resident program by block ID.
>ff18					RunNamed    .fill   4   ; Chain to resident program by name.
>ff1c					            .fill   4   ; reserved
>ff20					List        .fill   4   ; Returns a bit-set of available block-accessible devices.
>ff24					GetName     .fill   4   ; Gets the hardware level name of the given block device or media.
>ff28					GetSize     .fill   4   ; Get the number of raw sectors (48 bits) for the given device
>ff2c					Read        .fill   4   ; Read a raw sector (48 bit LBA)
>ff30					Write       .fill   4   ; Write a raw sector (48 bit LBA)
>ff34					Format      .fill   4   ; Perform a low-level format if the media support it.
>ff38					Export      .fill   4   ; Update the FileSystem table with the partition table (if present).
>ff3c					List        .fill   4   ; Returns a bit-set of available logical devices.
>ff40					GetSize     .fill   4   ; Get the size of the partition or logical device in sectors.
>ff44					MkFS        .fill   4   ; Creates a new file-system on the logical device.
>ff48					CheckFS     .fill   4   ; Checks the file-system for errors and corrects them.
>ff4c					Mount       .fill   4   ; Mark the file-system as available for File and Directory operations.
>ff50					Unmount     .fill   4   ; Mark the file-system as unavailable for File and Directory operations.
>ff54					ReadBlock   .fill   4   ; Read a partition-local raw sector on an unmounted device.
>ff58					WriteBlock  .fill   4   ; Write a partition-local raw sector on an unmounted device.
>ff5c					Open        .fill   4   ; Open the given file for read, create, or append.
>ff60					Read        .fill   4   ; Request bytes from a file opened for reading.
>ff64					Write       .fill   4   ; Write bytes to a file opened for create or append.
>ff68					Close       .fill   4   ; Close an open file.
>ff6c					Rename      .fill   4   ; Rename a closed file.
>ff70					Delete      .fill   4   ; Delete a closed file.
>ff74					Seek        .fill   4   ; Seek to a specific position in a file.
>ff78					Open        .fill   4   ; Open a directory for reading.
>ff7c					Read        .fill   4   ; Read a directory entry; may also return VOLUME and FREE events.
>ff80					Close       .fill   4   ; Close a directory once finished reading.
>ff84					MkDir       .fill   4   ; Create a directory
>ff88					RmDir       .fill   4   ; Delete a directory
>ff8c					            .fill   4   ; call gate
>ff90					GetIP       .fill   4   ; Get the local IP address.
>ff94					SetIP       .fill   4   ; Set the local IP address.
>ff98					GetDNS      .fill   4   ; Get the configured DNS IP address.
>ff9c					SetDNS      .fill   4   ; Set the configured DNS IP address.
>ffa0					SendICMP    .fill   4
>ffa4					Match       .fill   4
>ffa8					Init        .fill   4
>ffac					Send        .fill   4
>ffb0					Recv        .fill   4
>ffb4					Open        .fill   4
>ffb8					Accept      .fill   4
>ffbc					Reject      .fill   4
>ffc0					Send        .fill   4
>ffc4					Recv        .fill   4
>ffc8					Close       .fill   4
>ffcc					Reset       .fill   4   ; Re-init the display
>ffd0					GetSize     .fill   4   ; Returns rows/cols in kernel args.
>ffd4					DrawRow     .fill   4   ; Draw text/color buffers left-to-right
>ffd8					DrawColumn  .fill   4   ; Draw text/color buffers top-to-bottom
>ffdc					GetTime     .fill   4
>ffe0					SetTime     .fill   4
>ffe4					            .fill   12  ; 65816 vectors
>fff0					SetTimer    .fill   4
.00f0					args
.00f0					events
>00f0					dest        .word       ?   ; GetNextEvent copies event data here
>00f2					pending     .byte       ?   ; Negative count of pending events
.00f3					end
.00f3					run
>00f3					block_id    .byte   ?
.00f3					recv
=$fb					buf         = args.buf
=$fd					buflen      = args.buflen
.00f3					fs
.00f3					format
>00f3					drive       .byte       ?
>00f4					cookie      .byte       ?
=$fb					label       = args.buf
=$fd					label_len   = args.buflen
.00f3					mkfs
>00f3					drive       .byte       ?
>00f4					cookie      .byte       ?
=$fb					label       = args.buf
=$fd					label_len   = args.buflen
.00f3					file
.00f3					open
>00f3					drive       .byte       ?
>00f4					cookie      .byte       ?
=$fb					fname       = args.buf
=$fd					fname_len   = args.buflen
>00f5					mode        .byte       ?
=0					READ        = 0
=1					WRITE       = 1
=2					END         = 2
.00f3					read
>00f3					stream      .byte       ?
>00f4					buflen      .byte       ?
.00f3					write
>00f3					stream      .byte       ?
=$fb					buf         = args.buf
=$fd					buflen      = args.buflen
.00f3					seek
>00f3					stream      .byte       ?
>00f4					position    .dword      ?
.00f3					close
>00f3					stream      .byte       ?
.00f3					rename
>00f3					drive       .byte       ?
>00f4					cookie      .byte       ?
=$fb					old         = args.buf
=$fd					old_len     = args.buflen
=$f8					new         = args.ext
=$fa					new_len     = args.extlen
.00f3					delete
>00f3					drive       .byte       ?
>00f4					cookie      .byte       ?
=$fb					fname       = args.buf
=$fd					fname_len   = args.buflen
>00f5					mode        .byte       ?
=0					READ        = 0
=1					WRITE       = 1
=2					END         = 2
.00f3					directory
.00f3					open
>00f3					drive       .byte       ?
>00f4					cookie      .byte       ?
=$fb					path        = args.buf
=$fd					path_len    = args.buflen
.00f3					read
>00f3					stream      .byte       ?
>00f4					buflen      .byte       ?
.00f3					close
>00f3					stream      .byte       ?
.00f3					mkdir
>00f3					drive       .byte       ?
>00f4					cookie      .byte       ?
=$fb					path        = args.buf
=$fd					path_len    = args.buflen
.00f3					rmdir
>00f3					drive       .byte       ?
>00f4					cookie      .byte       ?
=$fb					path        = args.buf
=$fd					path_len    = args.buflen
.00f3					display
>00f3					x           .byte       ?   ; coordinate or size
>00f4					y           .byte       ?   ; coordinate or size
=$fb					text        = args.buf      ; text
=$f8					color       = args.ext      ; color
=$fb					buf         = args.buf      ; deprecated
=$f8					buf2        = args.ext      ; deprecated
=$fd					buflen      = args.buflen
.00f3					net
=$fb					socket      = args.buf
>00f3					src_port    .word       ?
>00f5					dest_port   .word       ?
>00f7					dest_ip     .fill       4
>00f3					accepted    .byte       ?
=$f8					buf         = args.ext
=$fa					buflen      = args.extlen
.00f3					config
.00f3					timer
>00f3					units       .byte       ?
=0					FRAMES      = 0
=1					SECONDS     = 1
=128					QUERY       = 128
>00f4					absolute    .byte       ?
>00f5					cookie      .byte       ?
=$f8					ext         = $f8
=$fa					extlen      = $fa
=$fb					buf         = $fb
=$fd					buflen      = $fd
=$fe					ptr         = $fe
.0000					events
>0000					dest        .word       ?   ; GetNextEvent copies event data here
>0002					pending     .byte       ?   ; Negative count of pending events
.0003					end
.0003					run
>0003					block_id    .byte   ?
.0003					recv
=$fb					buf         = args.buf
=$fd					buflen      = args.buflen
.0003					fs
.0003					format
>0003					drive       .byte       ?
>0004					cookie      .byte       ?
=$fb					label       = args.buf
=$fd					label_len   = args.buflen
.0003					mkfs
>0003					drive       .byte       ?
>0004					cookie      .byte       ?
=$fb					label       = args.buf
=$fd					label_len   = args.buflen
.0003					file
.0003					open
>0003					drive       .byte       ?
>0004					cookie      .byte       ?
=$fb					fname       = args.buf
=$fd					fname_len   = args.buflen
>0005					mode        .byte       ?
=0					READ        = 0
=1					WRITE       = 1
=2					END         = 2
.0003					read
>0003					stream      .byte       ?
>0004					buflen      .byte       ?
.0003					write
>0003					stream      .byte       ?
=$fb					buf         = args.buf
=$fd					buflen      = args.buflen
.0003					seek
>0003					stream      .byte       ?
>0004					position    .dword      ?
.0003					close
>0003					stream      .byte       ?
.0003					rename
>0003					drive       .byte       ?
>0004					cookie      .byte       ?
=$fb					old         = args.buf
=$fd					old_len     = args.buflen
=$f8					new         = args.ext
=$fa					new_len     = args.extlen
.0003					delete
>0003					drive       .byte       ?
>0004					cookie      .byte       ?
=$fb					fname       = args.buf
=$fd					fname_len   = args.buflen
>0005					mode        .byte       ?
=0					READ        = 0
=1					WRITE       = 1
=2					END         = 2
.0003					directory
.0003					open
>0003					drive       .byte       ?
>0004					cookie      .byte       ?
=$fb					path        = args.buf
=$fd					path_len    = args.buflen
.0003					read
>0003					stream      .byte       ?
>0004					buflen      .byte       ?
.0003					close
>0003					stream      .byte       ?
.0003					mkdir
>0003					drive       .byte       ?
>0004					cookie      .byte       ?
=$fb					path        = args.buf
=$fd					path_len    = args.buflen
.0003					rmdir
>0003					drive       .byte       ?
>0004					cookie      .byte       ?
=$fb					path        = args.buf
=$fd					path_len    = args.buflen
.0003					display
>0003					x           .byte       ?   ; coordinate or size
>0004					y           .byte       ?   ; coordinate or size
=$fb					text        = args.buf      ; text
=$f8					color       = args.ext      ; color
=$fb					buf         = args.buf      ; deprecated
=$f8					buf2        = args.ext      ; deprecated
=$fd					buflen      = args.buflen
.0003					net
=$fb					socket      = args.buf
>0003					src_port    .word       ?
>0005					dest_port   .word       ?
>0007					dest_ip     .fill       4
>0003					accepted    .byte       ?
=$f8					buf         = args.ext
=$fa					buflen      = args.extlen
.0003					config
.0003					timer
>0003					units       .byte       ?
=0					FRAMES      = 0
=1					SECONDS     = 1
=128					QUERY       = 128
>0004					absolute    .byte       ?
>0005					cookie      .byte       ?
=$f8					ext         = $f8
=$fa					extlen      = $fa
=$fb					buf         = $fb
=$fd					buflen      = $fd
=$fe					ptr         = $fe
>0000					dest        .word       ?   ; GetNextEvent copies event data here
>0002					pending     .byte       ?   ; Negative count of pending events
.0003					end
=$fb					buf         = args.buf
=$fd					buflen      = args.buflen
>0000					block_id    .byte   ?
.0000					format
>0000					drive       .byte       ?
>0001					cookie      .byte       ?
=$fb					label       = args.buf
=$fd					label_len   = args.buflen
.0000					mkfs
>0000					drive       .byte       ?
>0001					cookie      .byte       ?
=$fb					label       = args.buf
=$fd					label_len   = args.buflen
>0000					drive       .byte       ?
>0001					cookie      .byte       ?
=$fb					label       = args.buf
=$fd					label_len   = args.buflen
.0000					open
>0000					drive       .byte       ?
>0001					cookie      .byte       ?
=$fb					fname       = args.buf
=$fd					fname_len   = args.buflen
>0002					mode        .byte       ?
=0					READ        = 0
=1					WRITE       = 1
=2					END         = 2
.0000					read
>0000					stream      .byte       ?
>0001					buflen      .byte       ?
.0000					write
>0000					stream      .byte       ?
=$fb					buf         = args.buf
=$fd					buflen      = args.buflen
.0000					seek
>0000					stream      .byte       ?
>0001					position    .dword      ?
.0000					close
>0000					stream      .byte       ?
.0000					rename
>0000					drive       .byte       ?
>0001					cookie      .byte       ?
=$fb					old         = args.buf
=$fd					old_len     = args.buflen
=$f8					new         = args.ext
=$fa					new_len     = args.extlen
.0000					delete
>0000					drive       .byte       ?
>0001					cookie      .byte       ?
=$fb					fname       = args.buf
=$fd					fname_len   = args.buflen
>0002					mode        .byte       ?
=0					READ        = 0
=1					WRITE       = 1
=2					END         = 2
>0000					drive       .byte       ?
>0001					cookie      .byte       ?
=$fb					fname       = args.buf
=$fd					fname_len   = args.buflen
>0002					mode        .byte       ?
=0					READ        = 0
=1					WRITE       = 1
=2					END         = 2
>0000					stream      .byte       ?
>0001					buflen      .byte       ?
>0000					stream      .byte       ?
=$fb					buf         = args.buf
=$fd					buflen      = args.buflen
>0000					stream      .byte       ?
>0001					position    .dword      ?
>0000					stream      .byte       ?
>0000					drive       .byte       ?
>0001					cookie      .byte       ?
=$fb					old         = args.buf
=$fd					old_len     = args.buflen
=$f8					new         = args.ext
=$fa					new_len     = args.extlen
>0000					drive       .byte       ?
>0001					cookie      .byte       ?
=$fb					fnane       = args.buf
=$fd					fname_len   = args.buflen
.0000					open
>0000					drive       .byte       ?
>0001					cookie      .byte       ?
=$fb					path        = args.buf
=$fd					path_len    = args.buflen
.0000					read
>0000					stream      .byte       ?
>0001					buflen      .byte       ?
.0000					close
>0000					stream      .byte       ?
.0000					mkdir
>0000					drive       .byte       ?
>0001					cookie      .byte       ?
=$fb					path        = args.buf
=$fd					path_len    = args.buflen
.0000					rmdir
>0000					drive       .byte       ?
>0001					cookie      .byte       ?
=$fb					path        = args.buf
=$fd					path_len    = args.buflen
>0000					drive       .byte       ?
>0001					cookie      .byte       ?
=$fb					path        = args.buf
=$fd					path_len    = args.buflen
>0000					stream      .byte       ?
>0001					buflen      .byte       ?
>0000					stream      .byte       ?
>0000					x           .byte       ?   ; coordinate or size
>0001					y           .byte       ?   ; coordinate or size
=$fb					text        = args.buf      ; text
=$f8					color       = args.ext      ; color
=$fb					buf         = args.buf      ; deprecated
=$f8					buf2        = args.ext      ; deprecated
=$fd					buflen      = args.buflen
=$fb					socket      = args.buf
>0000					src_port    .word       ?
>0002					dest_port   .word       ?
>0004					dest_ip     .fill       4
>0000					accepted    .byte       ?
=$f8					buf         = args.ext
=$fa					buflen      = args.extlen
>0000					units       .byte       ?
=0					FRAMES      = 0
=1					SECONDS     = 1
=128					QUERY       = 128
>0001					absolute    .byte       ?
>0002					cookie      .byte       ?
>0000					century     .byte       ?
>0001					year        .byte       ?
>0002					month       .byte       ?
>0003					day         .byte       ?
>0004					hours       .byte       ?
>0005					minutes     .byte       ?
>0006					seconds     .byte       ?
>0007					centis      .byte       ?
.0008					size
>0000					            .word   ?   ; Reserved
>0002					            .word   ?   ; Deprecated
>0004					JOYSTICK    .word   ?   ; Game Controller changes.
>0006					DEVICE      .word   ?   ; Device added/removed.
>0008					PRESSED     .word   ?   ; Key pressed
>000a					RELEASED    .word   ?   ; Key released.
>000c					DELTA       .word   ?   ; Regular mouse move and button state
>000e					CLICKS      .word   ?   ; Click counts
>0010					NAME        .word   ?
>0012					SIZE        .word   ?
>0014					DATA        .word   ?   ; The read request has succeeded.
>0016					WROTE       .word   ?   ; The write request has completed.
>0018					FORMATTED   .word   ?   ; The low-level format has completed.
>001a					ERROR       .word   ?
>001c					SIZE        .word   ?
>001e					CREATED     .word   ?
>0020					CHECKED     .word   ?
>0022					DATA        .word   ?   ; The read request has succeeded.
>0024					WROTE       .word   ?   ; The write request has completed.
>0026					ERROR       .word   ?
>0028					NOT_FOUND   .word   ?   ; The file file was not found.
>002a					OPENED      .word   ?   ; The file was successfully opened.
>002c					DATA        .word   ?   ; The read request has succeeded.
>002e					WROTE       .word   ?   ; The write request has completed.
>0030					EOF         .word   ?   ; All file data has been read.
>0032					CLOSED      .word   ?   ; The close request has completed.
>0034					RENAMED     .word   ?   ; The rename request has completed.
>0036					DELETED     .word   ?   ; The delete request has completed.
>0038					ERROR       .word   ?   ; An error occured; close the file if opened.
>003a					SEEK        .word   ?   ; The seek request has completed.
>003c					OPENED      .word   ?   ; The directory open request succeeded.
>003e					VOLUME      .word   ?   ; A volume record was found.
>0040					FILE        .word   ?   ; A file record was found.
>0042					FREE        .word   ?   ; A file-system free-space record was found.
>0044					EOF         .word   ?   ; All data has been read.
>0046					CLOSED      .word   ?   ; The directory file has been closed.
>0048					ERROR       .word   ?   ; An error occured; user should close.
>004a					CREATED     .word   ?   ; The directory has been created.
>004c					DELETED     .word   ?   ; The directory has been deleted.
>004e					TCP         .word   ?
>0050					UDP         .word   ?
>0052					EXPIRED     .word   ?
>0054					TICK        .word   ?
>0000					type        .byte   ?   ; Enum above
>0001					buf         .byte   ?   ; page id or zero
>0002					ext         .byte   ?   ; page id or zero
.0003					key
>0003					keyboard    .byte   ?   ; Keyboard ID
>0004					raw         .byte   ?   ; Raw key ID
>0005					ascii       .byte   ?   ; ASCII value
>0006					flags       .byte   ?   ; Flags (META)
=$80					META        = $80       ; Meta key; no associated ASCII value.
.0003					mouse
.0003					delta
>0003					x           .byte   ?
>0004					y           .byte   ?
>0005					z           .byte   ?
>0006					buttons     .byte   ?
.0003					clicks
>0003					inner       .byte   ?
>0004					middle      .byte   ?
>0005					outer       .byte   ?
.0003					joystick
>0003					joy0        .byte   ?
>0004					joy1        .byte   ?
.0003					udp
>0003					token       .byte   ?   ; TODO: break out into fields
.0003					tcp
>0003					len         .byte   ?   ; Raw packet length.
.0003					file
>0003					stream      .byte   ?
>0004					cookie      .byte   ?
.0005					data
>0005					requested   .byte   ?   ; Requested number of bytes to read
>0006					read        .byte   ?   ; Number of bytes actually read
.0005					wrote
>0005					requested   .byte   ?   ; Requested number of bytes to read
>0006					wrote       .byte   ?   ; Number of bytes actually read
.0003					directory
>0003					stream      .byte   ?
>0004					cookie      .byte   ?
.0005					volume
>0005					len         .byte   ?   ; Length of volname (in buf)
>0006					flags       .byte   ?   ; block size, text encoding
.0005					file
>0005					len         .byte   ?
>0006					flags       .byte   ?   ; block scale, text encoding, approx size
.0005					free
>0005					flags       .byte   ?   ; block scale, text encoding, approx size
.0003					timer
>0003					value       .byte   ?
>0004					cookie      .byte   ?
>0000					keyboard    .byte   ?   ; Keyboard ID
>0001					raw         .byte   ?   ; Raw key ID
>0002					ascii       .byte   ?   ; ASCII value
>0003					flags       .byte   ?   ; Flags (META)
=$80					META        = $80       ; Meta key; no associated ASCII value.
.0000					delta
>0000					x           .byte   ?
>0001					y           .byte   ?
>0002					z           .byte   ?
>0003					buttons     .byte   ?
.0000					clicks
>0000					inner       .byte   ?
>0001					middle      .byte   ?
>0002					outer       .byte   ?
>0000					x           .byte   ?
>0001					y           .byte   ?
>0002					z           .byte   ?
>0003					buttons     .byte   ?
>0000					inner       .byte   ?
>0001					middle      .byte   ?
>0002					outer       .byte   ?
>0000					joy0        .byte   ?
>0001					joy1        .byte   ?
>0000					stream      .byte   ?
>0001					cookie      .byte   ?
.0002					data
>0002					requested   .byte   ?   ; Requested number of bytes to read
>0003					read        .byte   ?   ; Number of bytes actually read
.0002					wrote
>0002					requested   .byte   ?   ; Requested number of bytes to read
>0003					wrote       .byte   ?   ; Number of bytes actually read
>0000					requested   .byte   ?   ; Requested number of bytes to read
>0001					read        .byte   ?   ; Number of bytes actually read
>0000					requested   .byte   ?   ; Requested number of bytes to read
>0001					wrote       .byte   ?   ; Number of bytes actually read
>0000					stream      .byte   ?
>0001					cookie      .byte   ?
.0002					volume
>0002					len         .byte   ?   ; Length of volname (in buf)
>0003					flags       .byte   ?   ; block size, text encoding
.0002					file
>0002					len         .byte   ?
>0003					flags       .byte   ?   ; block scale, text encoding, approx size
.0002					free
>0002					flags       .byte   ?   ; block scale, text encoding, approx size
>0000					len         .byte   ?   ; Length of volname (in buf)
>0001					flags       .byte   ?   ; block size, text encoding
>0000					len         .byte   ?
>0001					flags       .byte   ?   ; block scale, text encoding, approx size
>0000					flags       .byte   ?   ; block scale, text encoding, approx size
>0000					free        .fill   6   ; blocks used/free
>0000					token       .byte   ?   ; TODO: break out into fields
>0000					len         .byte   ?   ; Raw packet length.
>0000					value       .byte   ?
>0001					cookie      .byte   ?

;******  Return to file: pendulum.asm

.00a0					event:
>00a0					type        .byte   ?   ; Enum above
>00a1					buf         .byte   ?   ; page id or zero
>00a2					ext         .byte   ?   ; page id or zero
.00a3					key
>00a3					keyboard    .byte   ?   ; Keyboard ID
>00a4					raw         .byte   ?   ; Raw key ID
>00a5					ascii       .byte   ?   ; ASCII value
>00a6					flags       .byte   ?   ; Flags (META)
=$80					META        = $80       ; Meta key; no associated ASCII value.
.00a3					mouse
.00a3					delta
>00a3					x           .byte   ?
>00a4					y           .byte   ?
>00a5					z           .byte   ?
>00a6					buttons     .byte   ?
.00a3					clicks
>00a3					inner       .byte   ?
>00a4					middle      .byte   ?
>00a5					outer       .byte   ?
.00a3					joystick
>00a3					joy0        .byte   ?
>00a4					joy1        .byte   ?
.00a3					udp
>00a3					token       .byte   ?   ; TODO: break out into fields
.00a3					tcp
>00a3					len         .byte   ?   ; Raw packet length.
.00a3					file
>00a3					stream      .byte   ?
>00a4					cookie      .byte   ?
.00a5					data
>00a5					requested   .byte   ?   ; Requested number of bytes to read
>00a6					read        .byte   ?   ; Number of bytes actually read
.00a5					wrote
>00a5					requested   .byte   ?   ; Requested number of bytes to read
>00a6					wrote       .byte   ?   ; Number of bytes actually read
.00a3					directory
>00a3					stream      .byte   ?
>00a4					cookie      .byte   ?
.00a5					volume
>00a5					len         .byte   ?   ; Length of volname (in buf)
>00a6					flags       .byte   ?   ; block size, text encoding
.00a5					file
>00a5					len         .byte   ?
>00a6					flags       .byte   ?   ; block scale, text encoding, approx size
.00a5					free
>00a5					flags       .byte   ?   ; block scale, text encoding, approx size
.00a3					timer
>00a3					value       .byte   ?
>00a4					cookie      .byte   ?
>2000	f2 56						.byte $f2,$56						; Required bytes for the Kernel to identify
>2002	04 01						.byte $04,$01						; how big is the program in 8K sections, What slot to map to
>2004	0b 20						.byte $0b,$20						; the starting address of your program
>2006	00 00 00 00					.byte $00,$00,$00,$00				; reserved
>200a	00						.byte $00							; terminating byte
.200b					SC:
.200b	64 01		stz $01				stz MMU_IO_CTRL						; should do this on every program
.200d	a9 a0		lda #$a0	        lda #<event
.200f	85 f0		sta $f0		        sta kernel.args.events
.2011	a9 00		lda #$00	        lda #>event
.2013	85 f1		sta $f1		        sta kernel.args.events+1
.2015	a9 24		lda #$24			lda #%00100100						; Graphic, Sprites Engine enabled  			|xx|GM|SP|TL|BM|GR|OV|TX|
.2017	8d 00 d0	sta $d000			sta VKY_MSTR_CTRL_0					;                  		                    | 0| 0| 1| 0| 0| 1| 0| 0|
.201a	a9 00		lda #$00			lda #%00000000						; Text mode options for the overlay 		|xx|xx|FS|FO|MS|2Y|2X|70|
.201c	8d 01 d0	sta $d001			sta VKY_MSTR_CTRL_1					; 320 x 240, 60 Hz, dbl X & Y				| 0| 0| 0| 0| 0| 0| 0| 0|
.201f	9c 04 d0	stz $d004			stz VKY_BRDR_CTRL					; No Border
.2022	a9 00		lda #$00			lda #$00							; Set the background color
.2024	8d 0f d0	sta $d00f			sta VKY_BKG_COL_R
.2027	a9 00		lda #$00			lda #$00
.2029	8d 0e d0	sta $d00e			sta VKY_BKG_COL_G
.202c	a9 00		lda #$00			lda #$00
.202e	8d 0d d0	sta $d00d			sta VKY_BKG_COL_B
.2031	a9 61		lda #$61			lda #<sprite1
.2033	8d df 23	sta $23df			sta spriteLoc
.2036	a9 24		lda #$24			lda #>sprite1
.2038	8d e0 23	sta $23e0			sta spriteLoc+1
.203b	a2 00		ldx #$00			ldx #$00
.203d					spriteLoop:
.203d	8a		txa				txa
.203e	0a		asl a				asl
.203f	0a		asl a				asl
.2040	0a		asl a				asl
.2041	a8		tay				tay
.2042	a9 61		lda #$61			lda #%01100001			; 8x8 sprite, layer 0, lut 0, enable on
.2044	99 00 d9	sta $d900,y			sta VKY_SP0,y
.2047	bd d4 22	lda $22d4,x			lda ballXLO,x
.204a	99 04 d9	sta $d904,y			sta VKY_SP0+SP_POS_X_L,Y
.204d	a9 00		lda #$00			lda #$00
.204f	99 05 d9	sta $d905,y			sta VKY_SP0+SP_POS_X_H,y
.2052	bd 04 23	lda $2304,x			lda ballYLO,X
.2055	99 06 d9	sta $d906,y			sta VKY_SP0+SP_POS_Y_L,Y
.2058	bd 1c 23	lda $231c,x			lda ballYHI,X
.205b	99 07 d9	sta $d907,y			sta VKY_SP0+SP_POS_Y_H,Y
.205e	ad df 23	lda $23df			lda spriteLoc
.2061	99 01 d9	sta $d901,y			sta VKY_SP0+SP_AD_L,y
.2064	ad e0 23	lda $23e0			lda spriteLoc+1
.2067	99 02 d9	sta $d902,y			sta VKY_SP0+SP_AD_M,y
.206a	a9 00		lda #$00			lda #$00
.206c	99 03 d9	sta $d903,y			sta VKY_SP0+SP_AD_H,y
.206f	18		clc				clc
.2070	ad df 23	lda $23df			lda spriteLoc
.2073	69 40		adc #$40			adc #64
.2075	8d df 23	sta $23df			sta spriteLoc
.2078	ad e0 23	lda $23e0			lda spriteLoc+1
.207b	69 00		adc #$00			adc #$00
.207d	8d e0 23	sta $23e0			sta spriteLoc+1
.2080	e8		inx				inx
.2081	e0 18		cpx #$18			cpx #24
.2083	d0 b8		bne $203d			bne spriteLoop
.2085	a9 01		lda #$01			lda #$01							; Change I/O control to page 1
.2087	85 01		sta $01				sta MMU_IO_CTRL
.2089	a9 e1		lda #$e1			lda #<CLUT0							; Set source pointer to CLUT for color information
.208b	85 80		sta $80				sta ptr_src
.208d	a9 23		lda #$23			lda #>CLUT0
.208f	85 81		sta $81				sta ptr_src+1
.2091	a9 00		lda #$00			lda #<VKY_GR_CLUT_0					; Set destination pointer to Graphics CLUT 0
.2093	85 82		sta $82				sta ptr_dst
.2095	a9 d0		lda #$d0			lda #>VKY_GR_CLUT_0
.2097	85 83		sta $83				sta ptr_dst+1
.2099	a2 00		ldx #$00			ldx #$00							; X is the number of colors to copy, check for 154
.209b	a0 20		ldy #$20			ldy #32
.209d					makeClut:
.209d	8c de 23	sty $23de			sty totalColors
.20a0					color_loop:
.20a0	a0 00		ldy #$00			ldy #$00							; Y points to the color component (Blue Red Green Alpha)
.20a2					comp_loop:
.20a2	b1 80		lda ($80),y			lda (ptr_src),y						; Read byte from our color table
.20a4	91 82		sta ($82),y			sta (ptr_dst),y						; write byte to the Graphic CLUT
.20a6	c8		iny				iny
.20a7	c0 04		cpy #$04			cpy #$04							; Do 4 bytes for one color + Alpha
.20a9	d0 f7		bne $20a2			bne comp_loop
.20ab	e8		inx				inx
.20ac	ec de 23	cpx $23de			cpx totalColors						; Loop for all colors of the CLUT
.20af	f0 1d		beq $20ce			beq done_lut
.20b1	18		clc				clc									; Move the source pointer to the next Color
.20b2	a5 80		lda $80				lda ptr_src
.20b4	69 04		adc #$04			adc #$04
.20b6	85 80		sta $80				sta ptr_src
.20b8	a5 81		lda $81				lda ptr_src+1
.20ba	69 00		adc #$00			adc #$00
.20bc	85 81		sta $81				sta ptr_src+1
.20be	18		clc				clc									; Move the destination pointer to the next Color
.20bf	a5 82		lda $82				lda ptr_dst
.20c1	69 04		adc #$04			adc #$04
.20c3	85 82		sta $82				sta ptr_dst
.20c5	a5 83		lda $83				lda ptr_dst+1
.20c7	69 00		adc #$00			adc #$00
.20c9	85 83		sta $83				sta ptr_dst+1
.20cb	4c a0 20	jmp $20a0			jmp color_loop						; and start copying the next color
.20ce					done_lut:
.20ce	64 01		stz $01				stz MMU_IO_CTRL
.20d0	a9 c0		lda #$c0			lda #$c0							; set the instrument for channel 0
.20d2	8d a1 dd	sta $dda1			sta MIDI_COM
.20d5	a9 0b		lda #$0b			lda #11								; this is the instrument number
.20d7	8d a1 dd	sta $dda1			sta MIDI_COM
.20da	a9 00		lda #$00			lda #kernel.args.timer.FRAMES		; set the Timer to Frames
.20dc	09 80		ora #$80			ora #kernel.args.timer.QUERY		; and query what frame we're on
.20de	85 f3		sta $f3				sta kernel.args.timer.units			; store in units parameter
.20e0	20 f0 ff	jsr $fff0			jsr kernel.Clock.SetTimer			; jsr to Kernel Routine
.20e3	b0 04		bcs $20e9			bcs skipSet							; If Carry set, ignore
.20e5	69 01		adc #$01			adc #$01							; if not add 1 to Accumulator for next frame
.20e7	85 d0		sta $d0				sta $d0
.20e9					skipSet:
.20e9	20 64 22	jsr $2264			jsr SetTimer						; Let's get the kernel set up for the timer
.20ec					loop:
.20ec	20 f2 20	jsr $20f2			jsr handle_events
.20ef	4c ec 20	jmp $20ec			jmp loop
.20f2					handle_events:
.20f2	a5 f2		lda $f2				lda kernel.args.events.pending		; Peek at the queue to see if anything is pending
.20f4	10 0b		bpl $2101			bpl done_handle_events				; Nothing to do
.20f6	20 00 ff	jsr $ff00			jsr kernel.NextEvent				; Get the next event.
.20f9	b0 06		bcs $2101			bcs done_handle_events				; If Carry is set, skip the handler
.20fb	20 02 21	jsr $2102			jsr dispatch						; Handle the event
.20fe	4c f2 20	jmp $20f2			jmp handle_events					; go and check for another event
.2101					done_handle_events:
.2101	60		rts				rts
.2102					dispatch:
.2102	a5 a0		lda $a0				lda event.type						; get the event type from Kernel
.2104	c9 52		cmp #$52			cmp #kernel.event.timer.EXPIRED		; is the event timer.EXPIRED?
.2106	f0 01		beq $2109			beq UpdateScreen					; run the screen update
.2108	60		rts				rts
.2109					UpdateScreen:
.2109	20 64 22	jsr $2264			jsr SetTimer						; reset timer for next SOF
.210c	20 10 21	jsr $2110			jsr moveBalls						; move the balls
.210f	60		rts				rts
.2110					moveBalls:
.2110	a2 00		ldx #$00			ldx #$00							; set X to zero to loop 24 balls
.2112					mbLoop:
.2112	8a		txa				txa									; transfer x to A
.2113	0a		asl a				asl									; and multiply by 8
.2114	0a		asl a				asl 								;		sprite control is 8 bytes large
.2115	0a		asl a				asl									;       this sets y at the start of each sprite
.2116	a8		tay				tay									; 		and store in y
.2117	bd 74 22	lda $2274,x			lda ballDir,x 						; Get the ball direction 1 for right FF for left
.211a	c9 ff		cmp #$ff			cmp #$ff							; check if we're going left
.211c	f0 37		beq $2155			beq goBack							; if yest, go to left routine
.211e					goForward:
.211e	18		clc				clc									; go right routine
.211f	bd bc 22	lda $22bc,x			lda ballXFR,x						; we're going to add the speed to the X paramter
.2122	7d 8c 22	adc $228c,x			adc ballSdF,x 						; using a single byte fixed point fraction
.2125	9d bc 22	sta $22bc,x			sta ballXFR,x
.2128	bd d4 22	lda $22d4,x			lda ballXLO,x
.212b	7d a4 22	adc $22a4,x			adc ballSdL,x
.212e	9d d4 22	sta $22d4,x			sta ballXLO,x
.2131	bd ec 22	lda $22ec,x			lda ballXHI,x
.2134	69 00		adc #$00			adc #$00
.2136	9d ec 22	sta $22ec,x			sta ballxHI,x
.2139	bd d4 22	lda $22d4,x			lda ballXLO,x 						; see if we hit the right side of the screen
.213c	c9 59		cmp #$59			cmp #$59
.213e	90 4a		bcc $218a			bcc placeBall						; no, let's set the sprite on the screen
.2140	bd ec 22	lda $22ec,x			lda ballxHI,x 						; need to check HI byte as well
.2143	f0 45		beq $218a			beq placeBall						; no, place sprite on screen
.2145	a9 ff		lda #$ff			lda #$ff							; yes, change the direction flag to $ff
.2147	9d 74 22	sta $2274,x			sta ballDir,x
.214a	20 a5 21	jsr $21a5			jsr reverseBack
.214d	20 eb 21	jsr $21eb			jsr makeMusic						; hit the note on the SAM chip
.2150	20 fc 21	jsr $21fc			jsr makeColor						; fill the ball with the correct color
.2153	80 35		bra $218a			bra placeBall						; and drop down to the opposite direction
.2155					goBack:
.2155	38		sec				sec 								; go left direction
.2156	bd bc 22	lda $22bc,x			lda ballXFR,x						; subtract the ball speed from the x potition
.2159	fd 8c 22	sbc $228c,x			sbc ballSdF,x
.215c	9d bc 22	sta $22bc,x			sta ballXFR,x
.215f	bd d4 22	lda $22d4,x			lda ballXLO,x
.2162	fd a4 22	sbc $22a4,x			sbc ballSdL,x
.2165	9d d4 22	sta $22d4,x			sta ballXLO,x
.2168	bd ec 22	lda $22ec,x			lda ballXHI,x
.216b	e9 00		sbc #$00			sbc #$00
.216d	9d ec 22	sta $22ec,x			sta ballxHI,x
.2170	bd d4 22	lda $22d4,x			lda ballXLO,x 						; check if we hit the left side of the screen
.2173	c9 1f		cmp #$1f			cmp #$1f
.2175	b0 13		bcs $218a			bcs placeBall						; no, place the sprite
.2177	bd ec 22	lda $22ec,x			lda ballxHI,x 						; we need to check the hi byte too
.217a	d0 0e		bne $218a			bne placeBall						; no, place the sprite
.217c	a9 01		lda #$01			lda #$01							; change the ball direction to right
.217e	9d 74 22	sta $2274,x			sta ballDir,x
.2181	20 c8 21	jsr $21c8			jsr reverseForward
.2184	20 eb 21	jsr $21eb			jsr makeMusic						; hit the note on the SAM chip
.2187	20 fc 21	jsr $21fc			jsr makeColor						; fill the ball with the correct color
.218a					placeBall:
.218a	bd d4 22	lda $22d4,x			lda ballXLO,X						; set the sprite position parameter
.218d	99 04 d9	sta $d904,y			sta VKY_SP0+SP_POS_X_L,Y
.2190	bd ec 22	lda $22ec,x			lda ballxHI,X
.2193	99 05 d9	sta $d905,y			sta VKY_SP0+SP_POS_X_H,y
.2196	20 0f 22	jsr $220f			jsr dropColor						; reduce the color intesity as it travels away from the edge
.2199	20 3d 22	jsr $223d			jsr assignColor						; and assign the color to the CLUT
.219c	e8		inx				inx									; go to next ball in sequence
.219d	e0 18		cpx #$18			cpx #24								; have we gone through all 24 balls
.219f	f0 03		beq $21a4			beq doneBallLoop					; yes skip the jmp command to top
.21a1	4c 12 21	jmp $2112			jmp mbLoop
.21a4					doneBallLoop:
.21a4	60		rts				rts
.21a5					reverseBack:
.21a5	38		sec				sec
.21a6	bd bc 22	lda $22bc,x			lda ballXFR,x
.21a9	e9 00		sbc #$00			sbc #$00
.21ab	8d dc 23	sta $23dc			sta resultFR
.21ae	bd d4 22	lda $22d4,x			lda ballXLO,x
.21b1	e9 59		sbc #$59			sbc #$59
.21b3	8d dd 23	sta $23dd			sta resultLO
.21b6	38		sec				sec
.21b7	a9 00		lda #$00			lda #$00
.21b9	ed dc 23	sbc $23dc			sbc resultFR
.21bc	9d bc 22	sta $22bc,x			sta ballXFR,x
.21bf	a9 59		lda #$59			lda #$59
.21c1	ed dd 23	sbc $23dd			sbc resultLO
.21c4	9d d4 22	sta $22d4,x			sta ballXLO,x
.21c7	60		rts				rts
.21c8					reverseForward:
.21c8	38		sec				sec
.21c9	a9 00		lda #$00			lda #$00
.21cb	fd bc 22	sbc $22bc,x			sbc ballXFR,x
.21ce	8d dc 23	sta $23dc			sta resultFR
.21d1	a9 1f		lda #$1f			lda #$1f
.21d3	fd d4 22	sbc $22d4,x			sbc ballXLO,x
.21d6	8d dd 23	sta $23dd			sta resultLO
.21d9	18		clc				clc
.21da	a9 00		lda #$00			lda #$00
.21dc	6d dc 23	adc $23dc			adc resultFR
.21df	9d bc 22	sta $22bc,x			sta ballXFR,x
.21e2	a9 1f		lda #$1f			lda #$1f
.21e4	6d dd 23	adc $23dd			adc resultLO
.21e7	9d d4 22	sta $22d4,x			sta ballXLO,x
.21ea	60		rts				rts
.21eb					makeMusic:
.21eb	a9 90		lda #$90			lda #$90							; set channel 0
.21ed	8d a1 dd	sta $dda1			sta MIDI_COM
.21f0	bd 34 23	lda $2334,x			lda ballNote,X						; send note value based on what ball hit the edge
.21f3	8d a1 dd	sta $dda1			sta MIDI_COM
.21f6	a9 40		lda #$40			lda #$40							; volume is default velocity
.21f8	8d a1 dd	sta $dda1			sta MIDI_COM
.21fb	60		rts				rts
.21fc					makeColor:
.21fc	bd 94 23	lda $2394,x			lda colorG,X						; get the reference color
.21ff	9d 4c 23	sta $234c,x			sta ballG,X							; and store it in the ball
.2202	bd ac 23	lda $23ac,x			lda colorR,X						; for all three colors
.2205	9d 64 23	sta $2364,x			sta ballR,X
.2208	bd c4 23	lda $23c4,x			lda colorB,X
.220b	9d 7c 23	sta $237c,x			sta ballB,X
.220e	60		rts				rts
.220f					dropColor:
.220f	de 4c 23	dec $234c,x			dec ballG,X							; each cycle reduce the color value by one
.2212	de 64 23	dec $2364,x			dec ballR,x
.2215	de 7c 23	dec $237c,x			dec ballB,x
.2218	bd 4c 23	lda $234c,x			lda ballG,X							; check if we've gone too far
.221b	c9 ff		cmp #$ff			cmp #$ff							; and reset to zero
.221d	d0 05		bne $2224			bne checkRed
.221f	a9 00		lda #$00			lda #$00
.2221	9d 4c 23	sta $234c,x			sta ballG,x
.2224					checkRed:
.2224	bd 64 23	lda $2364,x			lda ballR,x
.2227	c9 ff		cmp #$ff			cmp #$ff
.2229	d0 05		bne $2230			bne checkBlue
.222b	a9 00		lda #$00			lda #$00
.222d	9d 64 23	sta $2364,x			sta ballR,x
.2230					checkBlue:
.2230	bd 7c 23	lda $237c,x			lda ballB,x
.2233	c9 ff		cmp #$ff			cmp #$ff
.2235	d0 05		bne $223c			bne colorDone
.2237	a9 00		lda #$00			lda #$00
.2239	9d 7c 23	sta $237c,x			sta ballB,x
.223c					colorDone:
.223c	60		rts				rts
.223d					assignColor:
.223d	a9 01		lda #$01			lda #$01							; Change I/O control to page 1
.223f	85 01		sta $01				sta MMU_IO_CTRL
.2241	8a		txa				txa									; grab which ball we have
.2242	18		clc				clc
.2243	69 02		adc #$02			adc #$02							; and add two for the first color to first ball
.2245	0a		asl a				asl									; then multiply by 4 to get to the right
.2246	0a		asl a				asl									; location for the RGBA bytes for each color
.2247	a8		tay				tay									; and transfer to Y for indirect indexing
.2248	a9 00		lda #$00			lda #<VKY_GR_CLUT_0					; Set destination pointer to Graphics CLUT 0
.224a	85 82		sta $82				sta ptr_dst
.224c	a9 d0		lda #$d0			lda #>VKY_GR_CLUT_0
.224e	85 83		sta $83				sta ptr_dst+1
.2250	bd 4c 23	lda $234c,x			lda ballG,x 						; get the ball color
.2253	91 82		sta ($82),y			sta (ptr_dst),y						; and store it in the CLUT
.2255	c8		iny				iny									; incrment y for next color component
.2256	bd 64 23	lda $2364,x			lda ballR,x 						; and repeat
.2259	91 82		sta ($82),y			sta (ptr_dst),y
.225b	c8		iny				iny
.225c	bd 7c 23	lda $237c,x			lda ballB,x
.225f	91 82		sta ($82),y			sta (ptr_dst),y
.2261	64 01		stz $01				stz MMU_IO_CTRL						; reset mmu IO to zero
.2263	60		rts				rts
.2264					SetTimer:
.2264	e6 d0		inc $d0				inc $d0
.2266	a5 d0		lda $d0				lda $d0
.2268	85 f4		sta $f4				sta kernel.args.timer.absolute		; store in timer.absolute paramter
.226a	85 f5		sta $f5				sta kernel.args.timer.cookie		; saved as a cookie to the kernel (same as frame number)
.226c	a9 00		lda #$00			lda #kernel.args.timer.FRAMES		; set the Timer to Frames
.226e	85 f3		sta $f3				sta kernel.args.timer.units			; store in units parameter
.2270	20 f0 ff	jsr $fff0			jsr kernel.Clock.SetTimer			; jsr to Kernel routine to set timer
.2273	60		rts				rts
>2274	01 01 01 01 01 01 01 01		ballDir:	.byte $01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01
>227c	01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01
>228c	00 f0 e0 d0 c0 b0 a0 90		ballSdF:	.byte $00,$f0,$e0,$d0,$c0,$b0,$a0,$90,$80,$70,$60,$50,$40,$30,$20,$10,$00,$f0,$e0,$d0,$c0,$b0,$a0,$90
>2294	80 70 60 50 40 30 20 10 00 f0 e0 d0 c0 b0 a0 90
>22a4	02 01 01 01 01 01 01 01		ballSdL:	.byte $02,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$00,$00,$00,$00,$00,$00,$00
>22ac	01 01 01 01 01 01 01 01 01 00 00 00 00 00 00 00
>22bc	00 00 00 00 00 00 00 00		ballXFR:	.byte $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
>22c4	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
>22d4	20 20 20 20 20 20 20 20		ballXLO:	.byte $20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20
>22dc	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20
>22ec	00 00 00 00 00 00 00 00		ballXHI:	.byte $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
>22f4	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
>2304	21 2b 35 3f 49 53 5d 67		ballYLO:	.byte $21,$2b,$35,$3f,$49,$53,$5d,$67,$71,$7b,$85,$8f,$99,$a3,$ad,$b7,$c1,$cb,$d5,$df,$e9,$f3,$fd,$07
>230c	71 7b 85 8f 99 a3 ad b7 c1 cb d5 df e9 f3 fd 07
>231c	00 00 00 00 00 00 00 00		ballYHI:	.byte $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$01
>2324	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 01
>2334	3c 3b 3a 39 38 37 36 35		ballNote:	.byte 60, 59, 58, 57, 56, 55, 54, 53, 52 ,51 ,50, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37
>233c	34 33 32 31 30 2f 2e 2d 2c 2b 2a 29 28 27 26 25
>234c	00 00 00 00 00 00 00 00		ballG:		.byte $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
>2354	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
>2364	00 00 00 00 00 00 00 00		ballR:		.byte $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
>236c	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
>237c	00 00 00 00 00 00 00 00		ballB:		.byte $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
>2384	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
>2394	00 00 00 00 00 00 3f 7f		colorG:		.byte $00,$00,        $00,       $00,     $00, $00,   $3F,   $7F,   $BF,    $FF, $FF,    $FF,     $FF,$FF,      $FF,   $FF,  $FF,   $BF,       $7F, $3F,   $00,  $00,    $00,     $00
>239c	bf ff ff ff ff ff ff ff ff bf 7f 3f 00 00 00 00
>23ac	ff bf 7f 3f 00 00 00 00		colorR:		.byte $FF,$BF,        $7F,       $3F,     $00, $00,   $00,   $00,   $00,    $00, $00,    $00,     $00,$3F,      $7F,   $BF,  $FF,   $FF,       $FF, $FF,   $FF,  $FF,    $FF,     $FF
>23b4	00 00 00 00 00 3f 7f bf ff ff ff ff ff ff ff ff
>23c4	ff ff ff ff ff bf bf bf		colorB:		.byte $FF,$FF,        $FF,       $FF,     $FF, $BF,   $BF,   $BF,   $BF,    $BF, $7F,    $7F,     $7F,$7F,      $3F,   $3F,  $3F,   $3F,       $00, $00,   $00,  $00,    $00,     $00
>23cc	bf bf 7f 7f 7f 7f 3f 3f 3f 3f 00 00 00 00 00 00
>23dc	00				resultFR:	.byte $00
>23dd	00				resultLO:	.byte $00
>23de	20				totalColors:	.byte 32
>23df	00 00				spriteLoc:		.word $0000

;******  Processing file: ball.s

.23e1					CLUT0:
>23e1	00 00 00 ff				.byte	$0,$0,$0,$ff
>23e5	ff ff ff ff				.byte	$ff,$ff,$ff,$ff
>23e9	3c 28 45 ff				.byte	$3c,$28,$45,$ff
>23ed	31 39 66 ff				.byte	$31,$39,$66,$ff
>23f1	3b 56 8f ff				.byte	$3b,$56,$8f,$ff
>23f5	26 71 df ff				.byte	$26,$71,$df,$ff
>23f9	66 a0 d9 ff				.byte	$66,$a0,$d9,$ff
>23fd	9a c3 ee ff				.byte	$9a,$c3,$ee,$ff
>2401	36 f2 fb ff				.byte	$36,$f2,$fb,$ff
>2405	50 e5 99 ff				.byte	$50,$e5,$99,$ff
>2409	30 be 6a ff				.byte	$30,$be,$6a,$ff
>240d	6e 94 37 ff				.byte	$6e,$94,$37,$ff
>2411	2f 69 4b ff				.byte	$2f,$69,$4b,$ff
>2415	24 4b 52 ff				.byte	$24,$4b,$52,$ff
>2419	39 3c 32 ff				.byte	$39,$3c,$32,$ff
>241d	74 3f 3f ff				.byte	$74,$3f,$3f,$ff
>2421	82 60 30 ff				.byte	$82,$60,$30,$ff
>2425	e1 6e 5b ff				.byte	$e1,$6e,$5b,$ff
>2429	ff 9b 63 ff				.byte	$ff,$9b,$63,$ff
>242d	e4 cd 5f ff				.byte	$e4,$cd,$5f,$ff
>2431	fc db cb ff				.byte	$fc,$db,$cb,$ff
>2435	ba 7b d7 ff				.byte	$ba,$7b,$d7,$ff
>2439	b7 ad 9b ff				.byte	$b7,$ad,$9b,$ff
>243d	87 7e 84 ff				.byte	$87,$7e,$84,$ff
>2441	6a 6a 69 ff				.byte	$6a,$6a,$69,$ff
>2445	52 56 59 ff				.byte	$52,$56,$59,$ff
>2449	8a 42 76 ff				.byte	$8a,$42,$76,$ff
>244d	32 32 ac ff				.byte	$32,$32,$ac,$ff
>2451	63 57 d9 ff				.byte	$63,$57,$d9,$ff
>2455	ba 7b d7 ff				.byte	$ba,$7b,$d7,$ff
>2459	4a 97 8f ff				.byte	$4a,$97,$8f,$ff
>245d	30 6f 8a ff				.byte	$30,$6f,$8a,$ff
.2461					sprite1:
>2461	00 00 01 01 01 01 00 00			.byte	$0,$0,$1,$1,$1,$1,$0,$0
>2469	00 01 02 02 02 02 01 00			.byte	$0,$1,$2,$2,$2,$2,$1,$0
>2471	01 02 02 02 02 02 02 01			.byte	$1,$2,$2,$2,$2,$2,$2,$1
>2479	01 02 02 02 02 02 02 01			.byte	$1,$2,$2,$2,$2,$2,$2,$1
>2481	01 02 02 02 02 02 02 01			.byte	$1,$2,$2,$2,$2,$2,$2,$1
>2489	01 02 02 02 02 02 02 01			.byte	$1,$2,$2,$2,$2,$2,$2,$1
>2491	00 01 02 02 02 02 01 00			.byte	$0,$1,$2,$2,$2,$2,$1,$0
>2499	00 00 01 01 01 01 00 00			.byte	$0,$0,$1,$1,$1,$1,$0,$0
.24a1					sprite2:
>24a1	00 00 01 01 01 01 00 00			.byte	$0,$0,$1,$1,$1,$1,$0,$0
>24a9	00 01 03 03 03 03 01 00			.byte	$0,$1,$3,$3,$3,$3,$1,$0
>24b1	01 03 03 03 03 03 03 01			.byte	$1,$3,$3,$3,$3,$3,$3,$1
>24b9	01 03 03 03 03 03 03 01			.byte	$1,$3,$3,$3,$3,$3,$3,$1
>24c1	01 03 03 03 03 03 03 01			.byte	$1,$3,$3,$3,$3,$3,$3,$1
>24c9	01 03 03 03 03 03 03 01			.byte	$1,$3,$3,$3,$3,$3,$3,$1
>24d1	00 01 03 03 03 03 01 00			.byte	$0,$1,$3,$3,$3,$3,$1,$0
>24d9	00 00 01 01 01 01 00 00			.byte	$0,$0,$1,$1,$1,$1,$0,$0
.24e1					sprite3:
>24e1	00 00 01 01 01 01 00 00			.byte	$0,$0,$1,$1,$1,$1,$0,$0
>24e9	00 01 04 04 04 04 01 00			.byte	$0,$1,$4,$4,$4,$4,$1,$0
>24f1	01 04 04 04 04 04 04 01			.byte	$1,$4,$4,$4,$4,$4,$4,$1
>24f9	01 04 04 04 04 04 04 01			.byte	$1,$4,$4,$4,$4,$4,$4,$1
>2501	01 04 04 04 04 04 04 01			.byte	$1,$4,$4,$4,$4,$4,$4,$1
>2509	01 04 04 04 04 04 04 01			.byte	$1,$4,$4,$4,$4,$4,$4,$1
>2511	00 01 04 04 04 04 01 00			.byte	$0,$1,$4,$4,$4,$4,$1,$0
>2519	00 00 01 01 01 01 00 00			.byte	$0,$0,$1,$1,$1,$1,$0,$0
.2521					sprite4:
>2521	00 00 01 01 01 01 00 00			.byte	$0,$0,$1,$1,$1,$1,$0,$0
>2529	00 01 05 05 05 05 01 00			.byte	$0,$1,$5,$5,$5,$5,$1,$0
>2531	01 05 05 05 05 05 05 01			.byte	$1,$5,$5,$5,$5,$5,$5,$1
>2539	01 05 05 05 05 05 05 01			.byte	$1,$5,$5,$5,$5,$5,$5,$1
>2541	01 05 05 05 05 05 05 01			.byte	$1,$5,$5,$5,$5,$5,$5,$1
>2549	01 05 05 05 05 05 05 01			.byte	$1,$5,$5,$5,$5,$5,$5,$1
>2551	00 01 05 05 05 05 01 00			.byte	$0,$1,$5,$5,$5,$5,$1,$0
>2559	00 00 01 01 01 01 00 00			.byte	$0,$0,$1,$1,$1,$1,$0,$0
.2561					sprite5:
>2561	00 00 01 01 01 01 00 00			.byte	$0,$0,$1,$1,$1,$1,$0,$0
>2569	00 01 06 06 06 06 01 00			.byte	$0,$1,$6,$6,$6,$6,$1,$0
>2571	01 06 06 06 06 06 06 01			.byte	$1,$6,$6,$6,$6,$6,$6,$1
>2579	01 06 06 06 06 06 06 01			.byte	$1,$6,$6,$6,$6,$6,$6,$1
>2581	01 06 06 06 06 06 06 01			.byte	$1,$6,$6,$6,$6,$6,$6,$1
>2589	01 06 06 06 06 06 06 01			.byte	$1,$6,$6,$6,$6,$6,$6,$1
>2591	00 01 06 06 06 06 01 00			.byte	$0,$1,$6,$6,$6,$6,$1,$0
>2599	00 00 01 01 01 01 00 00			.byte	$0,$0,$1,$1,$1,$1,$0,$0
.25a1					sprite6:
>25a1	00 00 01 01 01 01 00 00			.byte	$0,$0,$1,$1,$1,$1,$0,$0
>25a9	00 01 07 07 07 07 01 00			.byte	$0,$1,$7,$7,$7,$7,$1,$0
>25b1	01 07 07 07 07 07 07 01			.byte	$1,$7,$7,$7,$7,$7,$7,$1
>25b9	01 07 07 07 07 07 07 01			.byte	$1,$7,$7,$7,$7,$7,$7,$1
>25c1	01 07 07 07 07 07 07 01			.byte	$1,$7,$7,$7,$7,$7,$7,$1
>25c9	01 07 07 07 07 07 07 01			.byte	$1,$7,$7,$7,$7,$7,$7,$1
>25d1	00 01 07 07 07 07 01 00			.byte	$0,$1,$7,$7,$7,$7,$1,$0
>25d9	00 00 01 01 01 01 00 00			.byte	$0,$0,$1,$1,$1,$1,$0,$0
.25e1					sprite7:
>25e1	00 00 01 01 01 01 00 00			.byte	$0,$0,$1,$1,$1,$1,$0,$0
>25e9	00 01 08 08 08 08 01 00			.byte	$0,$1,$8,$8,$8,$8,$1,$0
>25f1	01 08 08 08 08 08 08 01			.byte	$1,$8,$8,$8,$8,$8,$8,$1
>25f9	01 08 08 08 08 08 08 01			.byte	$1,$8,$8,$8,$8,$8,$8,$1
>2601	01 08 08 08 08 08 08 01			.byte	$1,$8,$8,$8,$8,$8,$8,$1
>2609	01 08 08 08 08 08 08 01			.byte	$1,$8,$8,$8,$8,$8,$8,$1
>2611	00 01 08 08 08 08 01 00			.byte	$0,$1,$8,$8,$8,$8,$1,$0
>2619	00 00 01 01 01 01 00 00			.byte	$0,$0,$1,$1,$1,$1,$0,$0
.2621					sprite8:
>2621	00 00 01 01 01 01 00 00			.byte	$0,$0,$1,$1,$1,$1,$0,$0
>2629	00 01 09 09 09 09 01 00			.byte	$0,$1,$9,$9,$9,$9,$1,$0
>2631	01 09 09 09 09 09 09 01			.byte	$1,$9,$9,$9,$9,$9,$9,$1
>2639	01 09 09 09 09 09 09 01			.byte	$1,$9,$9,$9,$9,$9,$9,$1
>2641	01 09 09 09 09 09 09 01			.byte	$1,$9,$9,$9,$9,$9,$9,$1
>2649	01 09 09 09 09 09 09 01			.byte	$1,$9,$9,$9,$9,$9,$9,$1
>2651	00 01 09 09 09 09 01 00			.byte	$0,$1,$9,$9,$9,$9,$1,$0
>2659	00 00 01 01 01 01 00 00			.byte	$0,$0,$1,$1,$1,$1,$0,$0
.2661					sprite9:
>2661	00 00 01 01 01 01 00 00			.byte	$0,$0,$1,$1,$1,$1,$0,$0
>2669	00 01 0a 0a 0a 0a 01 00			.byte	$0,$1,$a,$a,$a,$a,$1,$0
>2671	01 0a 0a 0a 0a 0a 0a 01			.byte	$1,$a,$a,$a,$a,$a,$a,$1
>2679	01 0a 0a 0a 0a 0a 0a 01			.byte	$1,$a,$a,$a,$a,$a,$a,$1
>2681	01 0a 0a 0a 0a 0a 0a 01			.byte	$1,$a,$a,$a,$a,$a,$a,$1
>2689	01 0a 0a 0a 0a 0a 0a 01			.byte	$1,$a,$a,$a,$a,$a,$a,$1
>2691	00 01 0a 0a 0a 0a 01 00			.byte	$0,$1,$a,$a,$a,$a,$1,$0
>2699	00 00 01 01 01 01 00 00			.byte	$0,$0,$1,$1,$1,$1,$0,$0
.26a1					sprite10:
>26a1	00 00 01 01 01 01 00 00			.byte	$0,$0,$1,$1,$1,$1,$0,$0
>26a9	00 01 0b 0b 0b 0b 01 00			.byte	$0,$1,$b,$b,$b,$b,$1,$0
>26b1	01 0b 0b 0b 0b 0b 0b 01			.byte	$1,$b,$b,$b,$b,$b,$b,$1
>26b9	01 0b 0b 0b 0b 0b 0b 01			.byte	$1,$b,$b,$b,$b,$b,$b,$1
>26c1	01 0b 0b 0b 0b 0b 0b 01			.byte	$1,$b,$b,$b,$b,$b,$b,$1
>26c9	01 0b 0b 0b 0b 0b 0b 01			.byte	$1,$b,$b,$b,$b,$b,$b,$1
>26d1	00 01 0b 0b 0b 0b 01 00			.byte	$0,$1,$b,$b,$b,$b,$1,$0
>26d9	00 00 01 01 01 01 00 00			.byte	$0,$0,$1,$1,$1,$1,$0,$0
.26e1					sprite11:
>26e1	00 00 01 01 01 01 00 00			.byte	$0,$0,$1,$1,$1,$1,$0,$0
>26e9	00 01 0c 0c 0c 0c 01 00			.byte	$0,$1,$c,$c,$c,$c,$1,$0
>26f1	01 0c 0c 0c 0c 0c 0c 01			.byte	$1,$c,$c,$c,$c,$c,$c,$1
>26f9	01 0c 0c 0c 0c 0c 0c 01			.byte	$1,$c,$c,$c,$c,$c,$c,$1
>2701	01 0c 0c 0c 0c 0c 0c 01			.byte	$1,$c,$c,$c,$c,$c,$c,$1
>2709	01 0c 0c 0c 0c 0c 0c 01			.byte	$1,$c,$c,$c,$c,$c,$c,$1
>2711	00 01 0c 0c 0c 0c 01 00			.byte	$0,$1,$c,$c,$c,$c,$1,$0
>2719	00 00 01 01 01 01 00 00			.byte	$0,$0,$1,$1,$1,$1,$0,$0
.2721					sprite12:
>2721	00 00 01 01 01 01 00 00			.byte	$0,$0,$1,$1,$1,$1,$0,$0
>2729	00 01 0d 0d 0d 0d 01 00			.byte	$0,$1,$d,$d,$d,$d,$1,$0
>2731	01 0d 0d 0d 0d 0d 0d 01			.byte	$1,$d,$d,$d,$d,$d,$d,$1
>2739	01 0d 0d 0d 0d 0d 0d 01			.byte	$1,$d,$d,$d,$d,$d,$d,$1
>2741	01 0d 0d 0d 0d 0d 0d 01			.byte	$1,$d,$d,$d,$d,$d,$d,$1
>2749	01 0d 0d 0d 0d 0d 0d 01			.byte	$1,$d,$d,$d,$d,$d,$d,$1
>2751	00 01 0d 0d 0d 0d 01 00			.byte	$0,$1,$d,$d,$d,$d,$1,$0
>2759	00 00 01 01 01 01 00 00			.byte	$0,$0,$1,$1,$1,$1,$0,$0
.2761					sprite13:
>2761	00 00 01 01 01 01 00 00			.byte	$0,$0,$1,$1,$1,$1,$0,$0
>2769	00 01 0e 0e 0e 0e 01 00			.byte	$0,$1,$e,$e,$e,$e,$1,$0
>2771	01 0e 0e 0e 0e 0e 0e 01			.byte	$1,$e,$e,$e,$e,$e,$e,$1
>2779	01 0e 0e 0e 0e 0e 0e 01			.byte	$1,$e,$e,$e,$e,$e,$e,$1
>2781	01 0e 0e 0e 0e 0e 0e 01			.byte	$1,$e,$e,$e,$e,$e,$e,$1
>2789	01 0e 0e 0e 0e 0e 0e 01			.byte	$1,$e,$e,$e,$e,$e,$e,$1
>2791	00 01 0e 0e 0e 0e 01 00			.byte	$0,$1,$e,$e,$e,$e,$1,$0
>2799	00 00 01 01 01 01 00 00			.byte	$0,$0,$1,$1,$1,$1,$0,$0
.27a1					sprite14:
>27a1	00 00 01 01 01 01 00 00			.byte	$0,$0,$1,$1,$1,$1,$0,$0
>27a9	00 01 0f 0f 0f 0f 01 00			.byte	$0,$1,$f,$f,$f,$f,$1,$0
>27b1	01 0f 0f 0f 0f 0f 0f 01			.byte	$1,$f,$f,$f,$f,$f,$f,$1
>27b9	01 0f 0f 0f 0f 0f 0f 01			.byte	$1,$f,$f,$f,$f,$f,$f,$1
>27c1	01 0f 0f 0f 0f 0f 0f 01			.byte	$1,$f,$f,$f,$f,$f,$f,$1
>27c9	01 0f 0f 0f 0f 0f 0f 01			.byte	$1,$f,$f,$f,$f,$f,$f,$1
>27d1	00 01 0f 0f 0f 0f 01 00			.byte	$0,$1,$f,$f,$f,$f,$1,$0
>27d9	00 00 01 01 01 01 00 00			.byte	$0,$0,$1,$1,$1,$1,$0,$0
.27e1					sprite15:
>27e1	00 00 01 01 01 01 00 00			.byte	$0,$0,$1,$1,$1,$1,$0,$0
>27e9	00 01 10 10 10 10 01 00			.byte	$0,$1,$10,$10,$10,$10,$1,$0
>27f1	01 10 10 10 10 10 10 01			.byte	$1,$10,$10,$10,$10,$10,$10,$1
>27f9	01 10 10 10 10 10 10 01			.byte	$1,$10,$10,$10,$10,$10,$10,$1
>2801	01 10 10 10 10 10 10 01			.byte	$1,$10,$10,$10,$10,$10,$10,$1
>2809	01 10 10 10 10 10 10 01			.byte	$1,$10,$10,$10,$10,$10,$10,$1
>2811	00 01 10 10 10 10 01 00			.byte	$0,$1,$10,$10,$10,$10,$1,$0
>2819	00 00 01 01 01 01 00 00			.byte	$0,$0,$1,$1,$1,$1,$0,$0
.2821					sprite16:
>2821	00 00 01 01 01 01 00 00			.byte	$0,$0,$1,$1,$1,$1,$0,$0
>2829	00 01 11 11 11 11 01 00			.byte	$0,$1,$11,$11,$11,$11,$1,$0
>2831	01 11 11 11 11 11 11 01			.byte	$1,$11,$11,$11,$11,$11,$11,$1
>2839	01 11 11 11 11 11 11 01			.byte	$1,$11,$11,$11,$11,$11,$11,$1
>2841	01 11 11 11 11 11 11 01			.byte	$1,$11,$11,$11,$11,$11,$11,$1
>2849	01 11 11 11 11 11 11 01			.byte	$1,$11,$11,$11,$11,$11,$11,$1
>2851	00 01 11 11 11 11 01 00			.byte	$0,$1,$11,$11,$11,$11,$1,$0
>2859	00 00 01 01 01 01 00 00			.byte	$0,$0,$1,$1,$1,$1,$0,$0
.2861					sprite17:
>2861	00 00 01 01 01 01 00 00			.byte	$0,$0,$1,$1,$1,$1,$0,$0
>2869	00 01 12 12 12 12 01 00			.byte	$0,$1,$12,$12,$12,$12,$1,$0
>2871	01 12 12 12 12 12 12 01			.byte	$1,$12,$12,$12,$12,$12,$12,$1
>2879	01 12 12 12 12 12 12 01			.byte	$1,$12,$12,$12,$12,$12,$12,$1
>2881	01 12 12 12 12 12 12 01			.byte	$1,$12,$12,$12,$12,$12,$12,$1
>2889	01 12 12 12 12 12 12 01			.byte	$1,$12,$12,$12,$12,$12,$12,$1
>2891	00 01 12 12 12 12 01 00			.byte	$0,$1,$12,$12,$12,$12,$1,$0
>2899	00 00 01 01 01 01 00 00			.byte	$0,$0,$1,$1,$1,$1,$0,$0
.28a1					sprite18:
>28a1	00 00 01 01 01 01 00 00			.byte	$0,$0,$1,$1,$1,$1,$0,$0
>28a9	00 01 13 13 13 13 01 00			.byte	$0,$1,$13,$13,$13,$13,$1,$0
>28b1	01 13 13 13 13 13 13 01			.byte	$1,$13,$13,$13,$13,$13,$13,$1
>28b9	01 13 13 13 13 13 13 01			.byte	$1,$13,$13,$13,$13,$13,$13,$1
>28c1	01 13 13 13 13 13 13 01			.byte	$1,$13,$13,$13,$13,$13,$13,$1
>28c9	01 13 13 13 13 13 13 01			.byte	$1,$13,$13,$13,$13,$13,$13,$1
>28d1	00 01 13 13 13 13 01 00			.byte	$0,$1,$13,$13,$13,$13,$1,$0
>28d9	00 00 01 01 01 01 00 00			.byte	$0,$0,$1,$1,$1,$1,$0,$0
.28e1					sprite19:
>28e1	00 00 01 01 01 01 00 00			.byte	$0,$0,$1,$1,$1,$1,$0,$0
>28e9	00 01 14 14 14 14 01 00			.byte	$0,$1,$14,$14,$14,$14,$1,$0
>28f1	01 14 14 14 14 14 14 01			.byte	$1,$14,$14,$14,$14,$14,$14,$1
>28f9	01 14 14 14 14 14 14 01			.byte	$1,$14,$14,$14,$14,$14,$14,$1
>2901	01 14 14 14 14 14 14 01			.byte	$1,$14,$14,$14,$14,$14,$14,$1
>2909	01 14 14 14 14 14 14 01			.byte	$1,$14,$14,$14,$14,$14,$14,$1
>2911	00 01 14 14 14 14 01 00			.byte	$0,$1,$14,$14,$14,$14,$1,$0
>2919	00 00 01 01 01 01 00 00			.byte	$0,$0,$1,$1,$1,$1,$0,$0
.2921					sprite20:
>2921	00 00 01 01 01 01 00 00			.byte	$0,$0,$1,$1,$1,$1,$0,$0
>2929	00 01 15 15 15 15 01 00			.byte	$0,$1,$15,$15,$15,$15,$1,$0
>2931	01 15 15 15 15 15 15 01			.byte	$1,$15,$15,$15,$15,$15,$15,$1
>2939	01 15 15 15 15 15 15 01			.byte	$1,$15,$15,$15,$15,$15,$15,$1
>2941	01 15 15 15 15 15 15 01			.byte	$1,$15,$15,$15,$15,$15,$15,$1
>2949	01 15 15 15 15 15 15 01			.byte	$1,$15,$15,$15,$15,$15,$15,$1
>2951	00 01 15 15 15 15 01 00			.byte	$0,$1,$15,$15,$15,$15,$1,$0
>2959	00 00 01 01 01 01 00 00			.byte	$0,$0,$1,$1,$1,$1,$0,$0
.2961					sprite21:
>2961	00 00 01 01 01 01 00 00			.byte	$0,$0,$1,$1,$1,$1,$0,$0
>2969	00 01 16 16 16 16 01 00			.byte	$0,$1,$16,$16,$16,$16,$1,$0
>2971	01 16 16 16 16 16 16 01			.byte	$1,$16,$16,$16,$16,$16,$16,$1
>2979	01 16 16 16 16 16 16 01			.byte	$1,$16,$16,$16,$16,$16,$16,$1
>2981	01 16 16 16 16 16 16 01			.byte	$1,$16,$16,$16,$16,$16,$16,$1
>2989	01 16 16 16 16 16 16 01			.byte	$1,$16,$16,$16,$16,$16,$16,$1
>2991	00 01 16 16 16 16 01 00			.byte	$0,$1,$16,$16,$16,$16,$1,$0
>2999	00 00 01 01 01 01 00 00			.byte	$0,$0,$1,$1,$1,$1,$0,$0
.29a1					sprite22:
>29a1	00 00 01 01 01 01 00 00			.byte	$0,$0,$1,$1,$1,$1,$0,$0
>29a9	00 01 17 17 17 17 01 00			.byte	$0,$1,$17,$17,$17,$17,$1,$0
>29b1	01 17 17 17 17 17 17 01			.byte	$1,$17,$17,$17,$17,$17,$17,$1
>29b9	01 17 17 17 17 17 17 01			.byte	$1,$17,$17,$17,$17,$17,$17,$1
>29c1	01 17 17 17 17 17 17 01			.byte	$1,$17,$17,$17,$17,$17,$17,$1
>29c9	01 17 17 17 17 17 17 01			.byte	$1,$17,$17,$17,$17,$17,$17,$1
>29d1	00 01 17 17 17 17 01 00			.byte	$0,$1,$17,$17,$17,$17,$1,$0
>29d9	00 00 01 01 01 01 00 00			.byte	$0,$0,$1,$1,$1,$1,$0,$0
.29e1					sprite23:
>29e1	00 00 01 01 01 01 00 00			.byte	$0,$0,$1,$1,$1,$1,$0,$0
>29e9	00 01 18 18 18 18 01 00			.byte	$0,$1,$18,$18,$18,$18,$1,$0
>29f1	01 18 18 18 18 18 18 01			.byte	$1,$18,$18,$18,$18,$18,$18,$1
>29f9	01 18 18 18 18 18 18 01			.byte	$1,$18,$18,$18,$18,$18,$18,$1
>2a01	01 18 18 18 18 18 18 01			.byte	$1,$18,$18,$18,$18,$18,$18,$1
>2a09	01 18 18 18 18 18 18 01			.byte	$1,$18,$18,$18,$18,$18,$18,$1
>2a11	00 01 18 18 18 18 01 00			.byte	$0,$1,$18,$18,$18,$18,$1,$0
>2a19	00 00 01 01 01 01 00 00			.byte	$0,$0,$1,$1,$1,$1,$0,$0
.2a21					sprite24:
>2a21	00 00 01 01 01 01 00 00			.byte	$0,$0,$1,$1,$1,$1,$0,$0
>2a29	00 01 19 19 19 19 01 00			.byte	$0,$1,$19,$19,$19,$19,$1,$0
>2a31	01 19 19 19 19 19 19 01			.byte	$1,$19,$19,$19,$19,$19,$19,$1
>2a39	01 19 19 19 19 19 19 01			.byte	$1,$19,$19,$19,$19,$19,$19,$1
>2a41	01 19 19 19 19 19 19 01			.byte	$1,$19,$19,$19,$19,$19,$19,$1
>2a49	01 19 19 19 19 19 19 01			.byte	$1,$19,$19,$19,$19,$19,$19,$1
>2a51	00 01 19 19 19 19 01 00			.byte	$0,$1,$19,$19,$19,$19,$1,$0
>2a59	00 00 01 01 01 01 00 00			.byte	$0,$0,$1,$1,$1,$1,$0,$0

;******  Return to file: pendulum.asm


;******  End of listing
